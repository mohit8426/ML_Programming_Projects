# -*- coding: utf-8 -*-
"""Lenet5_MohitK.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rdrrWqKoFHOlWSLZW0exuayv8b7zBPj1
"""

'''
Assignment-2 
Name: Mohit Shailesh Kulkarni
UTA ID: 1002031021
References: 
https://towardsdatascience.com/implementing-yann-lecuns-lenet-5-in-pytorch-5e05a0911320
https://www.analyticsvidhya.com/blog/2021/03/the-architecture-of-lenet-5/
https://datahacker.rs/lenet-5-implementation-tensorflow-2-0/
'''
import matplotlib.pyplot as plt
import numpy as np
from datetime import datetime 

import torch
from torch import nn, optim
from torch.utils.data import DataLoader
from torchvision import datasets, transforms
import torch.nn.functional as F
from torchsummaryX import summary as summaryX
from torchsummary import summary

device = ("cuda" if torch.cuda.is_available() else "cpu") # This is for the trainning from GPU or CPU

device

transform = transforms.Compose([
          transforms.Resize((32, 32)),
          transforms.ToTensor()
          ])

train_set = datasets.MNIST(root='DATA_MNIST/', download=True, train=True, transform=transform)
trainloader = torch.utils.data.DataLoader(train_set, batch_size=64, shuffle=True)

test_set = datasets.MNIST(root='DATA_MNIST/', train=False, transform=transform)
testloader = torch.utils.data.DataLoader(test_set, batch_size=64, shuffle=True)

train_data_size = len(train_set)
test_data_size = len(test_set)

training_data = enumerate(trainloader)
batch_idx, (images, labels) = next(training_data)
print(images.shape)
print(labels.shape)

testing_data = enumerate(testloader)
batch_idx, (images, labels) = next(testing_data)
print(images.shape)
print(labels.shape)

class LeNet5(nn.Module):
  def __init__(self):
    super(LeNet5, self).__init__()

    self.conv1 = nn.Conv2d(in_channels = 1, out_channels = 6, 
                           kernel_size = 5, stride = 1, padding = 0)
    self.conv2 = nn.Conv2d(in_channels = 6, out_channels = 16, 
                           kernel_size = 5, stride = 1, padding = 0)
    self.conv3 = nn.Conv2d(in_channels = 16, out_channels = 120, 
                           kernel_size = 5, stride = 1, padding = 0)
    self.linear1 = nn.Linear(120, 84)
    self.linear2 = nn.Linear(84, 10)
    self.tanh = nn.Tanh()
    self.avgpool = nn.AvgPool2d(kernel_size = 2, stride = 2)

  def forward(self, out):
    out = self.conv1(out)
    out = self.tanh(out)
    out = self.avgpool(out)
    out = self.conv2(out)
    out = self.tanh(out)
    out = self.avgpool(out)
    out = self.conv3(out)
    out = self.tanh(out)
    
    out = out.reshape(out.shape[0], -1)
    out = self.linear1(out)
    out = self.tanh(out)
    out = self.linear2(out)
    return out

model = LeNet5()
out = torch.randn(64,1,32,32)
output = model(out)

print(model)
summary(model, (1,32,32))
print("output.shape : ",output.shape)

optimizer = optim.Adam(model.parameters(), lr=0.001)
criterion = nn.CrossEntropyLoss()

epochs = 14
train_loss, val_loss = [], []

for epoch in range(epochs):
   
    total_train_loss = 0
    total_val_loss = 0

    model.train()
    total = 0
    
    # training our model
    for idx, (image, label) in enumerate(trainloader):

        image, label = image.to(device), label.to(device)
        optimizer.zero_grad()
        pred = model(image)

        loss = criterion(pred, label)
        total_train_loss += loss.item()

        pred = torch.nn.functional.softmax(pred, dim=1)
        for i, p in enumerate(pred):
            if label[i] == torch.max(p.data, 0)[1]:
                total = total + 1

        loss.backward()
        optimizer.step()

    total_train_loss = total_train_loss / (idx + 1)
    train_loss.append(total_train_loss)
    
    # validating our model
    model.eval()
    total1 = 0
    for idx, (image, label) in enumerate(testloader):
        image, label = image.to(device), label.to(device)
        pred = model(image)
        loss = criterion(pred, label)
        total_val_loss += loss.item()

        pred = torch.nn.functional.softmax(pred, dim=1)
        for i, p in enumerate(pred):
            if label[i] == torch.max(p.data, 0)[1]:
                total1 = total1 + 1

    train_acc = 100 * total / train_data_size
    valid_acc = 100 * total1 / test_data_size

    total_val_loss = total_val_loss / (idx + 1)
    val_loss.append(total_val_loss)

    if epoch % 1 == 0:
        print(f'{datetime.now().time().replace(microsecond=0)} --- ''\nEpoch: {}/{}, Train Loss: {:.4f}, Val Loss: {:.4f}, Train Acc: {:.4f}, Val Acc: {:.4f}'.format(epoch, epochs, total_train_loss, total_val_loss, train_acc, valid_acc))

plt.plot(train_loss)
plt.plot(val_loss)

ROW_IMG = 10
N_ROWS = 5

fig = plt.figure()
for index in range(1, ROW_IMG * N_ROWS + 1):
    plt.subplot(N_ROWS, ROW_IMG, index)
    plt.axis('off')
    plt.imshow(test_set.data[index], cmap='gray_r')
    
    with torch.no_grad():
        model.eval()
        probs = model(test_set[index][0].unsqueeze(0))
        
    title = f'{torch.argmax(probs)} (100%)'
    
    plt.title(title, fontsize=7)
fig.suptitle('LeNet-5 - predictions');

